class_name Permutation
extends RefCounted
## Pure math class: represents a permutation of n elements.
## mapping[i] = j means element at position i maps to position j.

var mapping: Array[int]

func _init(p_mapping: Array[int] = []) -> void:
	mapping = p_mapping

func size() -> int:
	return mapping.size()

func apply(i: int) -> int:
	return mapping[i]

func is_valid() -> bool:
	var n: int = size()
	if n == 0:
		return false
	var seen: Dictionary = {}
	for val in mapping:
		if val < 0 or val >= n or seen.has(val):
			return false
		seen[val] = true
	return seen.size() == n

func is_identity() -> bool:
	for i in range(size()):
		if mapping[i] != i:
			return false
	return true

func compose(other: Permutation) -> Permutation:
	## Returns self THEN other: result[i] = other.apply(self.apply(i))
	## This is standard right-to-left composition: (other . self)(i)
	## But for game UX we use "apply self first, then other"
	assert(size() == other.size(), "Permutation sizes must match")
	var result: Array[int] = []
	result.resize(size())
	for i in range(size()):
		result[i] = other.apply(apply(i))
	return Permutation.new(result)

func inverse() -> Permutation:
	var result: Array[int] = []
	result.resize(size())
	for i in range(size()):
		result[mapping[i]] = i
	return Permutation.new(result)

func order() -> int:
	## Returns smallest k > 0 such that self^k = identity
	var current: Permutation = self
	var identity: Permutation = Permutation.create_identity(size())
	for k in range(1, size() + 1):  # order divides n! but <= n for single perm
		if current.equals(identity):
			return k
		current = current.compose(self)
	# Fallback: should not reach here for valid permutations
	# but order can be up to lcm of cycle lengths
	var max_order: int = 1
	for i in range(size() + 1, _factorial(size()) + 1):
		current = current.compose(self)
		if current.equals(identity):
			return i
	return -1  # error

func equals(other: Permutation) -> bool:
	if size() != other.size():
		return false
	for i in range(size()):
		if mapping[i] != other.mapping[i]:
			return false
	return true

func to_cycle_notation() -> String:
	var visited: Dictionary = {}
	var cycles: Array[String] = []
	for i in range(size()):
		if visited.has(i):
			continue
		var cycle: Array[int] = []
		var j: int = i
		while not visited.has(j):
			visited[j] = true
			cycle.append(j)
			j = mapping[j]
		if cycle.size() > 1:
			var parts: Array[String] = []
			for c in cycle:
				parts.append(str(c))
			cycles.append("(" + " ".join(parts) + ")")
	if cycles.is_empty():
		return "()"
	return "".join(cycles)

# --- Static helpers ---

static func create_identity(n: int) -> Permutation:
	var m: Array[int] = []
	m.resize(n)
	for i in range(n):
		m[i] = i
	return Permutation.new(m)

static func from_array(arr: Array) -> Permutation:
	var typed: Array[int] = []
	for v in arr:
		typed.append(int(v))
	return Permutation.new(typed)

func _factorial(n: int) -> int:
	var result: int = 1
	for i in range(2, n + 1):
		result *= i
	return result


## Compose a list of permutations left-to-right: result = p0.compose(p1).compose(p2)...
## Returns identity if the list is empty.
static func compose_list(perms: Array, n: int = 0) -> Permutation:
	if perms.is_empty():
		return Permutation.create_identity(n if n > 0 else 1)
	var result: Permutation = perms[0]
	for i in range(1, perms.size()):
		result = result.compose(perms[i])
	return result


## Check if this permutation belongs to the given group (array of permutations).
func is_in_group(group: Array) -> bool:
	for g in group:
		if equals(g):
			return true
	return false


## Generate the subgroup generated by the given generator permutations.
## Uses iterative closure: repeatedly compose all pairs until no new elements appear.
## n is the permutation size (needed if generators is empty for identity size).
static func generate_subgroup_from(generators: Array, n: int) -> Array:
	# Start with identity
	var subgroup: Array = [Permutation.create_identity(n)]  # Array[Permutation]

	# Add all generators (if not already present)
	for gen in generators:
		var found: bool = false
		for s in subgroup:
			if s.equals(gen):
				found = true
				break
		if not found:
			subgroup.append(gen)

	# Iteratively close under composition and inverse
	var changed: bool = true
	while changed:
		changed = false
		var to_add: Array = []  # Array[Permutation]

		# Close under composition
		for a in subgroup:
			for b in subgroup:
				var product: Permutation = a.compose(b)
				var exists: bool = false
				for s in subgroup:
					if s.equals(product):
						exists = true
						break
				if not exists:
					for t in to_add:
						if t.equals(product):
							exists = true
							break
				if not exists:
					to_add.append(product)

		# Close under inverse
		for a in subgroup:
			var inv: Permutation = a.inverse()
			var exists: bool = false
			for s in subgroup:
				if s.equals(inv):
					exists = true
					break
			if not exists:
				for t in to_add:
					if t.equals(inv):
						exists = true
						break
			if not exists:
				to_add.append(inv)

		if not to_add.is_empty():
			subgroup.append_array(to_add)
			changed = true

	return subgroup
