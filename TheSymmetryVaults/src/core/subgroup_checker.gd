class_name SubgroupChecker
extends RefCounted
## Utility class for subgroup analysis operations.
## Provides normality checks, coset decomposition, and lattice construction.
## Used by Act 2 mechanics where players explore subgroup structure.


## Check if a subgroup H is normal in group G.
## A subgroup H is normal if for all g in G and h in H: g * h * g^-1 is in H.
static func is_normal(subgroup: Array, group: Array) -> bool:
	for g in group:
		var g_inv: Permutation = g.inverse()
		for h in subgroup:
			# Compute conjugate: g * h * g^-1
			var conjugate: Permutation = g.compose(h).compose(g_inv)
			var found := false
			for s in subgroup:
				if s.equals(conjugate):
					found = true
					break
			if not found:
				return false
	return true


## Compute left coset decomposition of group G by subgroup H.
## Returns array of cosets, where each coset is an array of permutations.
## The first coset is always H itself (the identity coset).
static func coset_decomposition(subgroup: Array, group: Array) -> Array:
	var cosets: Array = []  # Array[Array[Permutation]]
	var assigned: Array = []  # Array[Permutation] — elements already placed in a coset

	for g in group:
		# Check if g is already in some coset
		var already_assigned := false
		for a in assigned:
			if a.equals(g):
				already_assigned = true
				break
		if already_assigned:
			continue

		# Compute left coset g * H
		var coset: Array = []  # Array[Permutation]
		for h in subgroup:
			var element: Permutation = g.compose(h)
			coset.append(element)
			assigned.append(element)

		cosets.append(coset)

	return cosets


## Build the subgroup lattice of the given group.
## Returns a Dictionary with:
##   "subgroups": Array of {elements: Array[Permutation], order: int}
##   "inclusions": Array of [child_index, parent_index] pairs
##     where child is contained in parent
## For groups up to order 24 — full enumeration.
static func lattice(group: Array) -> Dictionary:
	# Find all subgroups by checking all subsets generated by each subset of generators
	var all_subgroups: Array = []  # Array[Array[Permutation]]

	if group.is_empty():
		return {"subgroups": [], "inclusions": []}

	var n: int = group[0].size()

	# Always include trivial subgroup {e} and the whole group
	# Use generator-based approach: for each subset of group elements,
	# generate the subgroup they span, then deduplicate.
	var seen_signatures: Array = []  # Array[String] — for deduplication

	# For each element, generate the cyclic subgroup it generates
	# For each pair, generate the subgroup they generate
	# This covers all subgroups for groups up to ~24 elements
	var candidate_generator_sets: Array = []  # Array[Array[Permutation]]

	# Single generators (cyclic subgroups)
	for g in group:
		candidate_generator_sets.append([g])

	# Pairs of generators
	for i in range(group.size()):
		for j in range(i + 1, group.size()):
			candidate_generator_sets.append([group[i], group[j]])

	# Generate and deduplicate subgroups
	for gens in candidate_generator_sets:
		var sub: Array = Permutation.generate_subgroup_from(gens, n)
		var sig := _subgroup_signature(sub)
		if not seen_signatures.has(sig):
			seen_signatures.append(sig)
			all_subgroups.append(sub)

	# Build subgroup info array
	var subgroup_info: Array = []  # Array[Dictionary]
	for sub in all_subgroups:
		subgroup_info.append({
			"elements": sub,
			"order": sub.size()
		})

	# Build inclusion edges: sub_i ⊂ sub_j
	var inclusions: Array = []  # Array[Array[int]]
	for i in range(all_subgroups.size()):
		for j in range(all_subgroups.size()):
			if i == j:
				continue
			if all_subgroups[i].size() >= all_subgroups[j].size():
				continue
			# Check if all_subgroups[i] ⊂ all_subgroups[j]
			if _is_subset_of(all_subgroups[i], all_subgroups[j]):
				# Check that this is a direct inclusion (no intermediate subgroup)
				var is_direct := true
				for k in range(all_subgroups.size()):
					if k == i or k == j:
						continue
					if all_subgroups[k].size() > all_subgroups[i].size() \
							and all_subgroups[k].size() < all_subgroups[j].size() \
							and _is_subset_of(all_subgroups[i], all_subgroups[k]) \
							and _is_subset_of(all_subgroups[k], all_subgroups[j]):
						is_direct = false
						break
				if is_direct:
					inclusions.append([i, j])

	return {
		"subgroups": subgroup_info,
		"inclusions": inclusions
	}


## Create a canonical signature for a subgroup (for deduplication).
## Sorts mapping arrays and joins them.
static func _subgroup_signature(sub: Array) -> String:
	var mappings: Array = []
	for p in sub:
		var s := ""
		for v in p.mapping:
			s += str(v) + ","
		mappings.append(s)
	mappings.sort()
	return "|".join(mappings)


## Check if all elements of sub_a are in sub_b.
static func _is_subset_of(sub_a: Array, sub_b: Array) -> bool:
	for a in sub_a:
		var found := false
		for b in sub_b:
			if a.equals(b):
				found = true
				break
		if not found:
			return false
	return true
