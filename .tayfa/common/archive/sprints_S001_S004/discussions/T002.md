# Task discussion T002: Technology Stack Decision

## [2026-02-21 00:01] boss (author)

### Task description

Choose the technology stack for The Symmetry Vaults. Requirements: desktop-first (Win/Mac/Linux), minimalist beautiful 2D (glowing crystals, particles, smooth 60fps animations), drag-and-drop, future Android portability. Evaluate: Godot, Pygame+moderngl, Electron+Canvas/WebGL, Love2D, others. Deliver: decision document with justification, module diagram, project structure, and data format specs for levels. MUST READ Game.txt first.

### Acceptance criteria

[To be clarified]

---

## [2026-02-21 09:00] architect (executor)

### Technology Stack Decision — The Symmetry Vaults

---

## 1. Requirements Analysis (from Game.txt)

### Core Gameplay Requirements
- **Graph rendering**: Nodes (crystals) with colors, edges (threads) with types (thickness, glow)
- **Drag-and-drop**: Player drags crystals to swap positions — primary interaction
- **Visual feedback**: Flash/shimmer on valid symmetry, dim/fade on invalid
- **Particle effects**: Glowing crystals, clean geometry, ambient particles
- **Smooth 60fps animations**: Transitions, swaps, lock-opening sequences
- **Key ring UI**: Collection of discovered permutations, composable

### Scale & Complexity by Act
| Act | Levels | Max Group Size | Special Mechanics |
|-----|--------|---------------|-------------------|
| 1 — Groups | 1–12 | D₄ (8 elements) | Cayley table composition button |
| 2 — Subgroups | 13–24 | ~24 elements | Node "gluing" (quotient), inner doors |
| 3 — Extensions | 25–36 | ~24+ elements | Color palette mixing, dual-screen (palette ↔ group) |
| 4 — Solvability | 37–45 | A₅ (60 elements) | Factorization chains, boss encounter |

### Platform Requirements
- **Primary**: Desktop — Windows, macOS, Linux
- **Future**: Android port
- **Performance**: 60fps on modest hardware

---

## 2. Candidate Evaluation

### Candidates Evaluated

| # | Technology | Language | Rendering |
|---|-----------|----------|-----------|
| 1 | **Godot 4** | GDScript/C# | Built-in 2D + shaders |
| 2 | **Pygame + ModernGL** | Python | OpenGL via ModernGL |
| 3 | **Electron + Canvas/WebGL** | JS/TS | HTML5 Canvas or WebGL |
| 4 | **Love2D** | Lua | OpenGL via LÖVE |
| 5 | **Python + Pyglet** | Python | OpenGL via Pyglet |
| 6 | **Raylib (Python bindings)** | Python/C | OpenGL via Raylib |

### Evaluation Criteria (weighted)

| Criterion | Weight | Description |
|-----------|--------|-------------|
| Visual quality ceiling | 25% | Shaders, glow, particles, smooth anims |
| Cross-platform desktop | 15% | Win/Mac/Linux from single codebase |
| Android portability | 15% | How feasible is future mobile port |
| Drag-and-drop ease | 10% | Native input handling for DnD |
| Developer velocity | 15% | How fast can the team build the prototype |
| Math integration | 10% | Ease of implementing permutation algebra in code |
| Bundle/distribution | 10% | Ease of shipping to end users |

### Scoring Matrix

| Criterion (weight) | Godot 4 | Pygame+MGL | Electron+WebGL | Love2D | Pyglet | Raylib |
|---|---|---|---|---|---|---|
| Visual quality (25%) | **9** — built-in shaders, particles, glow | 7 — possible but manual | 8 — WebGL shaders, CSS effects | 7 — shaders via GLSL | 6 — low-level | 7 — good but manual |
| Cross-platform (15%) | **10** — native export all 3 | 7 — pyinstaller works | 8 — Electron bundles | 8 — native all 3 | 7 — pyinstaller | 8 — native |
| Android port (15%) | **10** — first-class Android export | 3 — no real path | 5 — via Capacitor/PWA | 4 — partial via ports | 2 — no path | 6 — possible |
| Drag-and-drop (10%) | **9** — InputEvent system | 7 — pygame events | 9 — DOM events | 7 — love.mouse | 7 — pyglet events | 6 — manual |
| Dev velocity (15%) | **9** — scene system, editor, hot-reload | 7 — fast Python, no editor | 7 — JS ecosystem | 6 — Lua, less tooling | 6 — low-level | 5 — low-level |
| Math integration (10%) | 7 — GDScript ok, C# excellent | **9** — Python + numpy | 7 — JS ok | 5 — Lua limited | **9** — Python | 6 — C bindings |
| Distribution (10%) | **9** — one-click export | 5 — pyinstaller fragile | 7 — Electron large | 7 — love files | 5 — pyinstaller | 7 — native |
| **Weighted Total** | **9.15** | **6.55** | **7.30** | **6.45** | **5.90** | **6.35** |

### Decision: **Godot 4.3+ with GDScript**

---

## 3. Justification

### Why Godot Wins

1. **Visual quality with minimal effort**: Godot's 2D renderer has built-in support for:
   - `CanvasItem` shaders (glow, shimmer, pulse effects on crystals)
   - `GPUParticles2D` for ambient particle systems
   - `Tween` and `AnimationPlayer` for smooth 60fps transitions
   - `Light2D` and `PointLight2D` for crystal glow effects
   - This is critical — the game MUST look beautiful (glowing crystals, clean geometry)

2. **Android portability is solved**: Godot has first-class Android export. No architecture changes needed. This eliminates the biggest risk in the project.

3. **Scene system = natural level architecture**: Each level/vault is a Godot Scene. The node-crystal-edge graph maps perfectly to Godot's node tree.

4. **Development speed**: GDScript + Godot Editor enables rapid iteration. Hot-reload for visual tweaks. No boilerplate rendering code.

5. **Distribution**: One-click export to Windows (.exe), macOS (.app), Linux (.x86_64), Android (.apk).

### Why NOT the others

- **Pygame+ModernGL**: Excellent for math (Python), but no Android path, fragile distribution, and all rendering must be hand-coded. The visual quality requirement makes this too expensive.
- **Electron+WebGL**: Viable but 200MB+ bundle for a puzzle game is absurd. Performance on animations is unpredictable. Android via PWA is second-class.
- **Love2D**: Good 2D engine but Lua makes group-theory math code painful. Limited Android support. Smaller ecosystem.
- **Pyglet/Raylib**: Too low-level. Would spend sprint time on rendering infrastructure instead of game mechanics.

### Risk: Math in GDScript

GDScript lacks numpy, but our math is discrete (permutations, graph isomorphism, Cayley tables). Arrays and dictionaries are sufficient. For Act 4 (A₅, 60 elements), performance is still trivial — these are tiny data structures.

**Mitigation**: Core math logic will be in a clean, isolated module with pure functions. If GDScript proves limiting, Godot supports C# and GDExtension (C++) for hot modules.

---

## 4. Module Architecture

```
┌─────────────────────────────────────────────────────┐
│                   GAME APPLICATION                   │
├─────────────────────────────────────────────────────┤
│                                                      │
│  ┌─────────────┐  ┌──────────────┐  ┌────────────┐  │
│  │  GAME FLOW  │  │   LEVEL      │  │    UI      │  │
│  │  MANAGER    │  │   MANAGER    │  │   LAYER    │  │
│  │             │  │              │  │            │  │
│  │ • Act/Level │  │ • Load JSON  │  │ • HUD      │  │
│  │   progress  │  │ • Init scene │  │ • Key Ring │  │
│  │ • Save/Load │  │ • Win check  │  │ • Menus    │  │
│  │ • Cutscenes │  │ • Mechanics  │  │ • Dialogs  │  │
│  └──────┬──────┘  └──────┬───────┘  └─────┬──────┘  │
│         │                │                │          │
│  ┌──────┴────────────────┴────────────────┴──────┐  │
│  │              CORE ENGINE (autoload)            │  │
│  ├───────────────────────────────────────────────-│  │
│  │                                                │  │
│  │  ┌──────────────┐  ┌──────────────────────┐   │  │
│  │  │ Permutation  │  │   Graph Engine       │   │  │
│  │  │ Engine       │  │                      │   │  │
│  │  │              │  │ • CrystalGraph       │   │  │
│  │  │ • Permutation│  │   (nodes + edges)    │   │  │
│  │  │ • compose()  │  │ • apply_permutation()│   │  │
│  │  │ • inverse()  │  │ • is_automorphism()  │   │  │
│  │  │ • order()    │  │ • find_all_autos()   │   │  │
│  │  │ • CayleyTable│  │                      │   │  │
│  │  └──────────────┘  └──────────────────────┘   │  │
│  │                                                │  │
│  │  ┌──────────────┐  ┌──────────────────────┐   │  │
│  │  │ Key Ring     │  │  Subgroup Engine     │   │  │
│  │  │              │  │  (Act 2+)            │   │  │
│  │  │ • found[]    │  │                      │   │  │
│  │  │ • add_key()  │  │ • is_subgroup()      │   │  │
│  │  │ • is_complete│  │ • is_normal()        │   │  │
│  │  │ • compose_ui │  │ • quotient_graph()   │   │  │
│  │  └──────────────┘  └──────────────────────┘   │  │
│  │                                                │  │
│  │  ┌──────────────────────────────────────────┐  │  │
│  │  │ Palette Engine (Act 3+)                  │  │  │
│  │  │ • ColorPalette, mix_rules, extend()      │  │  │
│  │  │ • automorphisms_of_extension()           │  │  │
│  │  │ • galois_correspondence()                │  │  │
│  │  └──────────────────────────────────────────┘  │  │
│  └────────────────────────────────────────────────┘  │
│                                                      │
│  ┌────────────────────────────────────────────────┐  │
│  │              VISUAL LAYER                      │  │
│  ├────────────────────────────────────────────────┤  │
│  │  ┌──────────────┐  ┌──────────────────────┐   │  │
│  │  │ CrystalNode  │  │   EdgeRenderer      │   │  │
│  │  │ (Node2D)     │  │   (Node2D)          │   │  │
│  │  │              │  │                      │   │  │
│  │  │ • Sprite     │  │ • Line2D + shader   │   │  │
│  │  │ • Glow shader│  │ • thickness/glow    │   │  │
│  │  │ • Drag logic │  │ • type visuals      │   │  │
│  │  │ • Particles  │  │                      │   │  │
│  │  └──────────────┘  └──────────────────────┘   │  │
│  │                                                │  │
│  │  ┌──────────────┐  ┌──────────────────────┐   │  │
│  │  │ FeedbackFX   │  │   CameraController  │   │  │
│  │  │              │  │                      │   │  │
│  │  │ • valid_flash│  │ • zoom              │   │  │
│  │  │ • invalid_dim│  │ • pan               │   │  │
│  │  │ • lock_open  │  │ • shake             │   │  │
│  │  │ • particles  │  │ • smooth follow     │   │  │
│  │  └──────────────┘  └──────────────────────┘   │  │
│  └────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
```

### Module Responsibilities

| Module | Responsibility | Godot Implementation |
|--------|---------------|---------------------|
| **PermutationEngine** | Pure math: permutations, composition, inverse, order | GDScript class (autoload), no scene deps |
| **GraphEngine** | Graph structure, automorphism check, apply permutation | GDScript class (autoload), no scene deps |
| **KeyRing** | Track found symmetries, completeness check | GDScript Resource |
| **SubgroupEngine** | Subgroups, normality, quotient construction (Act 2+) | GDScript class (autoload) |
| **PaletteEngine** | Color mixing algebra, extensions (Act 3+) | GDScript class (autoload) |
| **LevelManager** | Load level JSON, instantiate scene, check win condition | Scene + script |
| **GameFlowManager** | Act/level progression, save/load, cutscenes | Autoload singleton |
| **CrystalNode** | Visual crystal: sprite, glow, drag-and-drop input | Node2D scene |
| **EdgeRenderer** | Visual edge between crystals: line, shader, type | Node2D scene |
| **FeedbackFX** | All juice: flash, shimmer, dim, particles, screen shake | Node + AnimationPlayer |
| **UILayer** | HUD, key ring display, menus, Cayley table UI | CanvasLayer scene |

### Key Design Principles

1. **Math is pure**: PermutationEngine, GraphEngine have ZERO rendering dependencies. They are pure-logic classes that can be unit-tested independently.
2. **Levels are data**: All level definitions are JSON files. No level-specific code. New levels = new JSON.
3. **Acts extend, not replace**: Act 2 adds SubgroupEngine alongside existing modules. Act 3 adds PaletteEngine. No rewrites.
4. **Scenes are composable**: CrystalNode and EdgeRenderer are reusable components. A level scene composes them dynamically from JSON data.

---

## 5. Project Structure

```
TheSymmetryVaults/
├── project.godot                 # Godot project config
├── export_presets.cfg            # Export configs (Win/Mac/Linux/Android)
│
├── src/
│   ├── core/                     # Pure logic (no rendering)
│   │   ├── permutation.gd        # Permutation class
│   │   ├── graph_engine.gd       # CrystalGraph, automorphism checks
│   │   ├── key_ring.gd           # Key ring (found symmetries)
│   │   ├── subgroup_engine.gd    # Act 2: subgroups, normality, quotients
│   │   ├── palette_engine.gd     # Act 3: color mixing, extensions
│   │   └── level_loader.gd       # Parse level JSON → game objects
│   │
│   ├── game/                     # Game flow
│   │   ├── game_manager.gd       # Autoload: act/level progression, save
│   │   ├── level_scene.gd        # Level scene controller
│   │   └── level_scene.tscn      # Base level scene template
│   │
│   ├── visual/                   # Rendering components
│   │   ├── crystal_node.gd       # Crystal: display, drag, glow
│   │   ├── crystal_node.tscn     # Crystal scene (Sprite2D + particles)
│   │   ├── edge_renderer.gd      # Edge: line, shader, type
│   │   ├── edge_renderer.tscn    # Edge scene (Line2D + shader)
│   │   ├── feedback_fx.gd        # Visual feedback manager
│   │   └── camera_controller.gd  # Camera: zoom, pan, shake
│   │
│   ├── ui/                       # UI layer
│   │   ├── hud.gd                # HUD controller
│   │   ├── hud.tscn              # HUD scene
│   │   ├── key_ring_display.gd   # Visual key ring
│   │   ├── key_ring_display.tscn
│   │   ├── cayley_table_ui.gd    # Cayley table (Act 1, L4+)
│   │   ├── main_menu.gd
│   │   ├── main_menu.tscn
│   │   └── level_select.tscn
│   │
│   └── shaders/                  # Visual shaders
│       ├── crystal_glow.gdshader
│       ├── edge_glow.gdshader
│       ├── valid_flash.gdshader
│       └── invalid_dim.gdshader
│
├── data/
│   ├── levels/
│   │   ├── act1/
│   │   │   ├── level_01.json
│   │   │   ├── level_02.json
│   │   │   └── ...
│   │   ├── act2/
│   │   ├── act3/
│   │   └── act4/
│   └── save/                     # Player save data (created at runtime)
│
├── assets/
│   ├── textures/
│   │   ├── crystals/             # Crystal sprites
│   │   └── ui/                   # UI elements
│   ├── audio/
│   │   ├── sfx/                  # Sound effects
│   │   └── music/                # Background music
│   └── fonts/
│
└── tests/                        # GDUnit4 test suite
    ├── test_permutation.gd
    ├── test_graph_engine.gd
    ├── test_key_ring.gd
    └── test_level_loader.gd
```

---

## 6. Data Format Specification — Level JSON

### Level File Schema

```json
{
  "meta": {
    "id": "act1_level01",
    "act": 1,
    "level": 1,
    "title": "The Triangle Vault",
    "subtitle": "Three crystals, three secrets",
    "group_name": "Z3",
    "group_order": 3
  },

  "graph": {
    "nodes": [
      {
        "id": 0,
        "color": "blue",
        "position": [300, 100],
        "label": "A"
      },
      {
        "id": 1,
        "color": "blue",
        "position": [150, 360],
        "label": "B"
      },
      {
        "id": 2,
        "color": "blue",
        "position": [450, 360],
        "label": "C"
      }
    ],

    "edges": [
      {
        "from": 0,
        "to": 1,
        "type": "standard",
        "weight": 1
      },
      {
        "from": 1,
        "to": 2,
        "type": "standard",
        "weight": 1
      },
      {
        "from": 2,
        "to": 0,
        "type": "standard",
        "weight": 1
      }
    ]
  },

  "symmetries": {
    "automorphisms": [
      {
        "id": "e",
        "mapping": [0, 1, 2],
        "name": "Identity",
        "description": "Everything stays"
      },
      {
        "id": "r1",
        "mapping": [1, 2, 0],
        "name": "Rotation 120°",
        "description": "One step clockwise"
      },
      {
        "id": "r2",
        "mapping": [2, 0, 1],
        "name": "Rotation 240°",
        "description": "Two steps clockwise"
      }
    ],
    "generators": ["r1"],
    "cayley_table": {
      "e":  {"e": "e",  "r1": "r1", "r2": "r2"},
      "r1": {"e": "r1", "r1": "r2", "r2": "e"},
      "r2": {"e": "r2", "r1": "e",  "r2": "r1"}
    }
  },

  "mechanics": {
    "allowed_actions": ["swap"],
    "show_cayley_button": false,
    "show_generators_hint": false,
    "inner_doors": [],
    "palette": null
  },

  "visuals": {
    "background_theme": "stone_vault",
    "ambient_particles": "dust_motes",
    "crystal_style": "basic_gem",
    "edge_style": "thin_thread"
  },

  "hints": [
    {
      "trigger": "after_30_seconds_no_action",
      "text": "Try dragging a crystal onto another one"
    },
    {
      "trigger": "after_first_valid",
      "text": "You found a symmetry! Can you find more?"
    }
  ]
}
```

### Key Format Decisions

**Node colors**: String identifiers (`"blue"`, `"red"`, `"gold"`) mapped to visual colors via theme config. This allows Act 3 palette extensions to add new color names.

**Edge types**: String identifiers (`"standard"`, `"thick"`, `"glowing"`, `"dashed"`) mapped to visual styles. Extensible for Act 2+ mechanics.

**Permutation format**: `mapping` array where `mapping[i] = j` means node `i` maps to position `j`. This is the standard one-line notation, compact and easy to compose programmatically.

**Cayley table**: Nested dictionary of automorphism ID → automorphism ID → result ID. Included in level data so the engine can validate and the UI can display it.

**Mechanics flags**: Per-level toggles for Act-specific features. `inner_doors` (Act 2), `palette` (Act 3) are null/empty until needed. No mechanic-specific code runs unless the flag is set.

### Save Data Format

```json
{
  "player": {
    "current_act": 1,
    "current_level": 3,
    "completed_levels": ["act1_level01", "act1_level02"],
    "level_states": {
      "act1_level03": {
        "found_keys": ["e", "r1"],
        "time_spent_seconds": 45,
        "attempts": 7
      }
    }
  },
  "settings": {
    "music_volume": 0.8,
    "sfx_volume": 1.0,
    "fullscreen": false
  }
}
```

---

## 7. Technology Versions & Tools

| Component | Version | Purpose |
|-----------|---------|---------|
| **Godot Engine** | 4.3+ | Game engine |
| **GDScript** | 2.0 | Primary language |
| **GDUnit4** | latest | Unit testing framework |
| **JSON** | — | Level data format |
| **Git** | — | Version control |

### Godot Project Settings (key)

- Renderer: **Compatibility** (OpenGL 3.3) — best cross-platform, sufficient for 2D
- Window: 1280×720 default, resizable
- Stretch mode: `canvas_items`, aspect `expand`
- Physics: disabled (not needed — pure visual game)

---

## 8. Interface Contracts for Developers

### For developer_game (T004): Core Engine API

```gdscript
# --- Permutation ---
class Permutation:
    var mapping: Array[int]  # [1, 2, 0] means 0→1, 1→2, 2→0

    func compose(other: Permutation) -> Permutation
    func inverse() -> Permutation
    func order() -> int
    func is_identity() -> bool
    func equals(other: Permutation) -> bool

# --- CrystalGraph ---
class CrystalGraph:
    var nodes: Array[CrystalNodeData]  # {id, color, position, label}
    var edges: Array[EdgeData]          # {from, to, type, weight}

    func apply_permutation(p: Permutation) -> CrystalGraph
    func is_automorphism(p: Permutation) -> bool
    func find_all_automorphisms() -> Array[Permutation]

# --- KeyRing ---
class KeyRing:
    var found: Array[Permutation]
    var target_count: int

    func add_key(p: Permutation) -> bool  # returns false if duplicate
    func is_complete() -> bool
    func contains(p: Permutation) -> bool
```

### For developer_ui (T005): Visual Layer API

```gdscript
# --- CrystalNodeVisual (extends Node2D) ---
# Signals:
signal crystal_grabbed(crystal_id: int)
signal crystal_dropped_on(from_id: int, to_id: int)

# Methods:
func set_color(color_name: String) -> void
func play_glow() -> void
func play_dim() -> void
func set_draggable(enabled: bool) -> void

# --- LevelScene ---
# Takes level JSON, creates CrystalNodeVisual + EdgeRenderer instances
# Listens for crystal_dropped_on → calls engine.is_automorphism()
# Triggers FeedbackFX based on result
```

---

## 9. Summary

| Decision | Choice |
|----------|--------|
| **Engine** | Godot 4.3+ |
| **Language** | GDScript (primary), C# (fallback for math if needed) |
| **Renderer** | Compatibility (OpenGL 3.3) |
| **Level format** | JSON |
| **Testing** | GDUnit4 |
| **Platforms** | Win/Mac/Linux (now), Android (future, no arch changes needed) |
| **Architecture** | Pure math core + visual layer + data-driven levels |

This architecture supports all 4 acts, 45 levels, and future Android port with zero structural changes. The math engine is isolated, testable, and independent of rendering. Levels are pure data. Visual effects leverage Godot's built-in 2D pipeline for the beautiful minimalist aesthetic the game requires.

---
